{"version":3,"sources":["mazeAlgorithms/verticalMaze.js","mazeAlgorithms/horizontalMaze.js","pathfindingVisualizer/Node/node.jsx","pathfindingVisualizer/navbar.jsx","pathfindingAlgorithms/breadthFirstSearch.js","pathfindingAlgorithms/depthFirstSearch.js","pathfindingVisualizer/pathfindingVisualizer.jsx","mazeAlgorithms/randomMaze.js","index.js"],"names":["walls","Node","props","cellHeight","row","col","isStart","isFinish","isWall","isVisited","isShortest","onMouseEnter","onMouseDown","onMouseUp","width","height","numRows","numColumns","extraClass","cellWidth","Math","floor","id","className","style","borderLeft","borderTop","brand","window","innerWidth","NavBar","useState","algorithm","setAlgorithm","maze","setMaze","pathState","setPathState","mazeState","setMazeState","speedState","setSpeedState","selectAlgorithm","selection","visualizingAlgorithm","generatingMaze","clearPath","selectMaze","clearGrid","clearTemp","changeSpeed","speed","value","updateSpeed","href","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","type","onClick","visualizeBFS","visualizeDFS","generateRandomMaze","generateVerticalMaze","generateHorizontalMaze","getUnvisitedNeighbours","node","grid","neighbours","push","length","filter","neighbour","neighbourNotInUnvisitedNodes","unvisitedNodes","verticalMaze","startNode","finishNode","vertical","range","horizontal","choice","random","num","addWall","getVerticalWalls","len","result","i","isStartFinish","tempWalls","temp","splice","wall","horizontalMaze","getHorizontalWalls","getInitialNum","innerHeight","initialNumRows","initialNumColumns","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getStartFinishNode","getInitialGrid","currentRow","createNode","distance","Infinity","totalDistance","previousNode","getNewGridWithWalls","newGrid","slice","newNode","getNewGridWithMaze","getGridWithoutPath","updateNodesForRender","nodesInShortestPathOrder","visitedNodesInOrder","PathfindingVisualizer","setGrid","mouseIsPressed","setMouseIsPressed","setVisualizingAlgorithm","setGeneratingMaze","setWidth","setHeight","setSpeed","mazeSpeed","setMazeSpeed","useEffect","addEventListener","updateDimensions","removeEventListener","document","getElementById","animateAlgorithm","setTimeout","animateShortestPath","animateMaze","Fragment","closestNode","shift","unvisitedNeighbours","unvisitedNeighbour","breadthFirstSearch","currentNode","unshift","getNodesInShortestPathOrderBFS","depthFirstSearch","getNodesInShortestPathOrderDFS","sort","randomMaze","path","class","map","rowId","key","nodeId","handleMouseDown","handleMouseEnter","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2e427af4.chunk.js","sourcesContent":["let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  //if there is noo start or end node in the row = num then remove 1 node at random from the temp walls\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","import React from \"react\";\nimport \"./node.css\";\n\nconst Node = (props) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    isWall,\n    isVisited,\n    isShortest,\n    onMouseEnter,\n    onMouseDown,\n    onMouseUp,\n    width,\n    height,\n    numRows,\n    numColumns,\n  } = props;\n\n  const extraClass = isStart\n    ? \"node node-start\"\n    : isFinish\n    ? \"node node-finish\"\n    : isWall\n    ? \"node-wall\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : isVisited\n    ? \"node node-visited\"\n    : \"node\";\n\n  // FINDING CELL WIDTH AND HEIGHT FOR STYLING\n  let cellWidth = Math.floor((width - 100) / numColumns);\n  let cellHeight;\n  if (width > 1500) {\n    cellHeight = Math.floor((height - 150) / numRows);\n  } else if (width > 1000) {\n    cellHeight = Math.floor((height - 70) / numRows);\n  } else if (width > 500) {\n    cellHeight = Math.floor((height - 60) / numRows);\n  } else if (width > 0) {\n    cellHeight = Math.floor((height - 50) / numRows);\n  }\n\n  return (\n    // making each cell as div\n    <div\n      id={`node-${row}-${col}`}\n      className={`${extraClass}`}\n      style={{\n        \"--width\": `${cellWidth}px`,\n        \"--height\": `${cellHeight}px`,\n        borderLeft: col !== 0 && 0,\n        borderTop: row !== 0 && 0,\n      }}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React, { useState } from \"react\";\nimport \"./navbar.css\";\n\nconst brand = window.innerWidth > 600 ? \"Pathfinding Visualizer\" : \"Pathfinder\";\n\nconst NavBar = (props) => {\n  const [algorithm, setAlgorithm] = useState(\"Visualize Algorithm\");\n  const [maze, setMaze] = useState(\"Generate Maze\");\n  const [pathState, setPathState] = useState(false); //whether there is path on grid\n  const [mazeState, setMazeState] = useState(false); //whether there is maze on grid\n  const [speedState, setSpeedState] = useState(\"Slow\");\n\n  function selectAlgorithm(selection) {\n    //if one algorithm is running we cannot select and run another algorithm\n    if (props.visualizingAlgorithm) {\n      return;\n    }\n    if (\n      selection === algorithm ||\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm!\"\n    ) {\n      setAlgorithm(selection);\n    }\n    //if new algo is selected the clear the prvious grid if it is traversed\n    else if (pathState) {\n      clearPath();\n      setAlgorithm(selection);\n    }\n    //select algo\n    else {\n      setAlgorithm(selection);\n    }\n  }\n\n  function selectMaze(selection) {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    if (\n      selection === maze ||\n      maze === \"Generate Maze\" ||\n      maze === \"Select a Maze!\"\n    ) {\n      setMaze(selection);\n    } else if (!mazeState) {\n      setMaze(selection);\n    } else {\n      clearGrid();\n      setMaze(selection);\n    }\n  }\n\n  function visualizeAlgorithm() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    //clear the already present path\n    if (pathState) {\n      clearTemp();\n      return;\n    }\n    if (\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm!\"\n    ) {\n      setAlgorithm(\"Select an Algorithm!\");\n    } else {\n      setPathState(true);\n      if (algorithm === \"Visualize Breadth First Search\")\n        props.visualizeBFS();\n      else if (algorithm === \"Visualize Depth First Search\")\n        props.visualizeDFS();\n    }\n  }\n\n  function generateMaze() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    // if somw path or walls already present the clear them first\n    if (mazeState || pathState) {\n      clearTemp();\n    }\n    if (maze === \"Generate Maze\" || maze === \"Select a Maze!\") {\n      setMaze(\"Select a Maze!\");\n    } else {\n      setMazeState(true);\n      if (maze === \"Generate Random Maze\") props.generateRandomMaze();\n      else if (maze === \"Generate Vertical Maze\") props.generateVerticalMaze();\n      else if (maze === \"Generate Horizontal Maze\")\n        props.generateHorizontalMaze();\n    }\n  }\n\n  function clearGrid() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setAlgorithm(\"Visualize Algorithm\");\n    setMaze(\"Generate Maze\");\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  //just clear the traversed path not walls\n  function clearPath() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearPath();\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  //clear the complete grid\n  function clearTemp() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  function changeSpeed(speed) {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    let value = [10, 10];\n    if (speed === \"Slow\") value = [50, 30];\n    else if (speed === \"Medium\") value = [25, 20];\n    else if (speed === \"Fast\") value = [10, 10];\n    setSpeedState(speed);\n    props.updateSpeed(value[0], value[1]);\n  }\n\n  return (\n    <nav className=\"navbar navbar-expand navbar-dark bg-dark\">\n      <a className=\"navbar-brand h1 mb-0\" href=\"/\">\n        {brand}\n      </a>\n      <div className=\"collapse navbar-collapse\" id=\"navbarNavDropdown\">\n        <ul className=\"navbar-nav mr-auto\">\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Algorithms\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Breadth First Search\")\n                  }\n                >\n                  Breadth First Search\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Depth First Search\")\n                  }\n                >\n                  Depth First Search\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Mazes\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Random Maze\")}\n                >\n                  Random Maze\n                </button>\n            \n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Vertical Maze\")}\n                >\n                  Vertical Division Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Horizontal Maze\")}\n                >\n                  Horizontal Division Maze\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Speed: {speedState}\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Slow\")}\n                >\n                  Slow\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Medium\")}\n                >\n                  Medium\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Fast\")}\n                >\n                  Fast\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n        </ul>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-success mr-2\"\n          onClick={() => visualizeAlgorithm()}\n        >\n          {algorithm}\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-success mr-2\"\n          onClick={() => generateMaze()}\n        >\n          {maze}\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-warning mr-2\"\n          onClick={() => clearGrid()}\n        >\n          Clear Gird\n        </button>\n      </div>\n    </nav>\n  );\n};\nexport default NavBar;\n","export function breadthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];                // keep track of unvisited nodes \n  let visitedNodesInOrder = [];           //to store path from src to dest\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();    //gives first element of unvisited nodes\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbour);\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode) {          //for printing shortest path\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);        //insert at beginning in array\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function depthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);   //push at top of stack\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useEffect } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\nimport {\n  breadthFirstSearch,\n  getNodesInShortestPathOrderBFS,\n} from \"../pathfindingAlgorithms/breadthFirstSearch\";\nimport {\n  depthFirstSearch,\n  getNodesInShortestPathOrderDFS,\n} from \"../pathfindingAlgorithms/depthFirstSearch\";\n\n//Maze Algorithms\nimport { randomMaze } from \"../mazeAlgorithms/randomMaze\";\nimport { verticalMaze } from \"../mazeAlgorithms/verticalMaze\";\nimport { horizontalMaze } from \"../mazeAlgorithms/horizontalMaze\";\n\n//get number of rows and columns based on windows width\n// finds row and column of grid according to screen dimensions\nconst [initialNumRows, initialNumColumns] = getInitialNum(\n  window.innerWidth,\n  window.innerHeight\n);\n\n//find random source and destination\nlet [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol] =\n  getStartFinishNode(initialNumRows, initialNumColumns);\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [visualizingAlgorithm, setVisualizingAlgorithm] = useState(false);\n  const [generatingMaze, setGeneratingMaze] = useState(false);\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n  const [numRows, setNumRows] = useState(initialNumRows);\n  const [numColumns, setNumColumns] = useState(initialNumColumns);\n  const [speed, setSpeed] = useState(10);\n  const [mazeSpeed, setMazeSpeed] = useState(10);\n\n  //useEffect\n  useEffect(() => {\n    window.addEventListener(\"resize\", updateDimensions);\n    setGrid(getInitialGrid(numRows, numColumns));\n    return () => {\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, [numRows, numColumns, width]);\n\n  const updateDimensions = () => {\n    setWidth(window.innerWidth);\n    setHeight(window.innerHeight);\n  };\n\n  const updateSpeed = (path, maze) => {\n    setSpeed(path);\n    setMazeSpeed(maze);\n  };\n\n  //when click mouse button wall created\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWalls(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  };\n\n  //when mouse button is pressed and we moving our cursor then wall is created\n  const handleMouseEnter = (row, col) => {\n    if (mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n\n    }\n  };\n\n  //when release mouse button\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n    \n  };\n\n  const clearGrid = () => {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          //each cell is div so we add the default class inital class-node\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(numRows, numColumns);\n    //making new grid and and assigning it to main grid\n    setGrid(newGrid);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n  };\n\n  const clearPath = () => {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        // only those cell which are traversed becomes default cell again without distubing the walls\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(grid);\n    setGrid(newGrid);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n  };\n\n  //print shortest path\n  const animateShortestPath = (\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    //if only one node is present i.e start and finish is same\n    if (nodesInShortestPathOrder.length === 1) setVisualizingAlgorithm(false);\n    //except the start node\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      //if we reach finish node and we\n      if (i === nodesInShortestPathOrder.length - 1) {\n        //after printing path we render the nodes if we make walls it is ok\n        //but if we rmove walls the it will restore its properties of animation\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n          setVisualizingAlgorithm(false);\n        }, i * (3 * speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * speed));\n    }\n  };\n\n  //all visited nodes and nodes in shortest path\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    setGrid(newGrid);\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      //if we reach the finish node then start animate shortest path route and stop the animate algo fun\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        // just add class node-visited into div to for animation\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  function visualizeBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeDFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  //animation for walls\n  const animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          clearGrid();\n          let newGrid = getNewGridWithMaze(grid, walls);\n          setGrid(newGrid);\n          setGeneratingMaze(false);\n        }, i * mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * mazeSpeed);\n    }\n  };\n\n  function generateRandomMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = randomMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateVerticalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateHorizontalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  return (\n    <React.Fragment>\n      <NavBar\n        visualizingAlgorithm={visualizingAlgorithm}\n        generatingMaze={generatingMaze}\n        visualizeBFS={visualizeBFS}\n        visualizeDFS={visualizeDFS}\n        generateRandomMaze={generateRandomMaze}\n        generateVerticalMaze={generateVerticalMaze}\n        generateHorizontalMaze={generateHorizontalMaze}\n        clearGrid={clearGrid}\n        clearPath={clearPath}\n        updateSpeed={updateSpeed}\n      />\n\n      <div class=\"d-flex flex-row flex-wrap m-2 justify-content-around\">\n        <div class=\"d-flex p-2\">\n          <div class=\"key wall\"></div>\n          <div> Wall</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key start\"></div>\n          <div>Start</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key end\"></div>\n          <div>Target</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key visited\"></div>\n          <div>Visited</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key success\"></div>\n          <div>Shortest-Path</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key\"></div>\n          <div>Unvisited</div>\n        </div>\n      </div>\n\n      <div\n        className={\n          visualizingAlgorithm || generatingMaze ? \"grid-visualizing\" : \"grid\"\n        }\n      >\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const {\n                  row,\n                  col,\n                  isStart,\n                  isFinish,\n                  isVisited,\n                  isShortest,\n                  isWall,\n                } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isVisited={isVisited}\n                    isShortest={isShortest}\n                    isWall={isWall}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    width={width}\n                    height={height}\n                    numRows={numRows}\n                    numColumns={numColumns}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </React.Fragment>\n  );\n};\n\n// finding rows and columns accoding to width and height\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\n//function to find random source and destnation nodes\nfunction getStartFinishNode(numRows, numColumns) {\n  //starting node is always in top-left part\n  let startNodeRow = Math.floor(Math.random() * (numRows / 2)) + 1; //added 1 to prevent out of bounds\n  let startNodeCol = Math.floor(Math.random() * (numColumns / 2)) + 1;\n\n  //finishing node is always in bottom-right part\n  let finishNodeRow =\n    Math.floor(numRows / 2) + Math.floor(Math.random() * (numRows / 2)) - 1;\n  let finishNodeCol =\n    Math.floor(numColumns / 2) +\n    Math.floor(Math.random() * (numColumns / 2)) -\n    1;\n\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\n//creating grid\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice(); //copy the old grid\n  let node = grid[row][col]; //updating node's wall\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice(); //copy the old grid\n  for (let row of grid) {\n    // removing paths from each cell of grid\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  //after printing path we render the nodes if we make walls it is ok\n  //but if we rmove walls the it will restore its properties of animation\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nexport default PathfindingVisualizer;\n","export function randomMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap/js/dist/dropdown\";\nimport PathfindingVisualizer from \"./pathfindingVisualizer/pathfindingVisualizer\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}