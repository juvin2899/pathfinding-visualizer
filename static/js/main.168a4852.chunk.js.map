{"version":3,"sources":["mazeAlgorithms/recursiveDivision.js","mazeAlgorithms/verticalMaze.js","mazeAlgorithms/horizontalMaze.js","pathfindingVisualizer/Node/node.jsx","pathfindingVisualizer/navbar.jsx","pathfindingAlgorithms/dijkstra.js","pathfindingAlgorithms/breadthFirstSearch.js","pathfindingAlgorithms/depthFirstSearch.js","pathfindingVisualizer/pathfindingVisualizer.jsx","mazeAlgorithms/randomMaze.js","index.js"],"names":["walls","Node","props","cellHeight","row","col","isStart","isFinish","isWall","isVisited","isShortest","onMouseEnter","onMouseDown","onMouseUp","width","height","numRows","numColumns","extraClass","cellWidth","Math","floor","id","className","style","borderLeft","borderTop","brand","window","innerWidth","NavBar","useState","algorithm","setAlgorithm","maze","setMaze","pathState","setPathState","mazeState","setMazeState","speedState","setSpeedState","selectAlgorithm","selection","visualizingAlgorithm","generatingMaze","clearPath","selectMaze","clearGrid","clearTemp","changeSpeed","speed","value","updateSpeed","href","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","type","onClick","visualizeDijkstra","visualizeBFS","visualizeDFS","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","Infinity","updateUnvisitedNeighbours","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","neighbourNotInUnvisitedNodes","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","dir","num","generateOddRandomNumber","addWall","slice","indexOf","len","result","i","array","max","randomNum","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","getInitialNum","innerHeight","initialNumRows","initialNumColumns","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getStartFinishNode","getInitialGrid","currentRow","createNode","totalDistance","getNewGridWithWalls","newGrid","newNode","getNewGridWithMaze","getGridWithoutPath","updateNodesForRender","nodesInShortestPathOrder","PathfindingVisualizer","setGrid","mouseIsPressed","setMouseIsPressed","setVisualizingAlgorithm","setGeneratingMaze","setWidth","setHeight","setSpeed","mazeSpeed","setMazeSpeed","useEffect","addEventListener","updateDimensions","removeEventListener","document","getElementById","animateAlgorithm","setTimeout","animateShortestPath","animateMaze","Fragment","currentNode","unshift","getNodesInShortestPathOrderDijkstra","breadthFirstSearch","getNodesInShortestPathOrderBFS","depthFirstSearch","getNodesInShortestPathOrderDFS","randomMaze","path","class","map","rowId","key","nodeId","handleMouseDown","handleMouseEnter","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.168a4852.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}\n","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n","import React from \"react\";\nimport \"./node.css\";\n\nconst Node = (props) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    isWall,\n    isVisited,\n    isShortest,\n    onMouseEnter,\n    onMouseDown,\n    onMouseUp,\n    width,\n    height,\n    numRows,\n    numColumns,\n  } = props;\n\n  const extraClass = isStart\n    ? \"node node-start\"\n    : isFinish\n    ? \"node node-finish\"\n    : isWall\n    ? \"node-wall\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : isVisited\n    ? \"node node-visited\"\n    : \"node\";\n\n  // FINDING CELL WIDTH AND HEIGHT FOR STYLING\n  let cellWidth = Math.floor((width - 100) / numColumns);\n  let cellHeight;\n  if (width > 1500) {\n    cellHeight = Math.floor((height - 150) / numRows);\n  } else if (width > 1000) {\n    cellHeight = Math.floor((height - 70) / numRows);\n  } else if (width > 500) {\n    cellHeight = Math.floor((height - 60) / numRows);\n  } else if (width > 0) {\n    cellHeight = Math.floor((height - 50) / numRows);\n  }\n\n  return (\n    // making each cell as div\n    <div\n      id={`node-${row}-${col}`}\n      className={`${extraClass}`}\n      style={{\n        \"--width\": `${cellWidth}px`,\n        \"--height\": `${cellHeight}px`,\n        borderLeft: col !== 0 && 0,\n        borderTop: row !== 0 && 0,\n      }}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React, { useState } from \"react\";\nimport \"./navbar.css\";\n\nconst brand = window.innerWidth > 600 ? \"Pathfinding Visualizer\" : \"Pathfinder\";\n\nconst NavBar = (props) => {\n  const [algorithm, setAlgorithm] = useState(\"Visualize Algorithm\");\n  const [maze, setMaze] = useState(\"Generate Maze\");\n  const [pathState, setPathState] = useState(false); //whether there is path on grid\n  const [mazeState, setMazeState] = useState(false); //whether there is maze on grid\n  const [speedState, setSpeedState] = useState(\"Slow\");\n\n  function selectAlgorithm(selection) {\n    //if one algorithm is running we cannot select and run another algorithm\n    if (props.visualizingAlgorithm) {\n      return;\n    }\n    if (\n      selection === algorithm ||\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm!\"\n    ) {\n      setAlgorithm(selection);\n    }\n    //if new algo is selected the clear the prvious grid if it is traversed\n    else if (pathState) {\n      clearPath();\n      setAlgorithm(selection);\n    }\n    //select algo\n    else {\n      setAlgorithm(selection);\n    }\n  }\n\n  function selectMaze(selection) {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    if (\n      selection === maze ||\n      maze === \"Generate Maze\" ||\n      maze === \"Select a Maze!\"\n    ) {\n      setMaze(selection);\n    } else if (!mazeState) {\n      setMaze(selection);\n    } else {\n      clearGrid();\n      setMaze(selection);\n    }\n  }\n\n  function visualizeAlgorithm() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    //clear the already present path\n    if (pathState) {\n      clearTemp();\n      return;\n    }\n    if (\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm!\"\n    ) {\n      setAlgorithm(\"Select an Algorithm!\");\n    } else {\n      setPathState(true);\n      if (algorithm === \"Visualize Dijkstra\") props.visualizeDijkstra();\n      else if (algorithm === \"Visualize Breadth First Search\")\n        props.visualizeBFS();\n      else if (algorithm === \"Visualize Depth First Search\")\n        props.visualizeDFS();\n    }\n  }\n\n  function generateMaze() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    // if somw path or walls already present the clear them first\n    if (mazeState || pathState) {\n      clearTemp();\n    }\n    if (maze === \"Generate Maze\" || maze === \"Select a Maze!\") {\n      setMaze(\"Select a Maze!\");\n    } else {\n      setMazeState(true);\n      if (maze === \"Generate Random Maze\") props.generateRandomMaze();\n      else if (maze === \"Generate Recursive Maze\")\n        props.generateRecursiveDivisionMaze();\n      else if (maze === \"Generate Vertical Maze\") props.generateVerticalMaze();\n      else if (maze === \"Generate Horizontal Maze\")\n        props.generateHorizontalMaze();\n    }\n  }\n\n  function clearGrid() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setAlgorithm(\"Visualize Algorithm\");\n    setMaze(\"Generate Maze\");\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  //just clear the traversed path not walls\n  function clearPath() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearPath();\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  //clear the complete grid\n  function clearTemp() {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setPathState(false);\n    setMazeState(false);\n  }\n\n  function changeSpeed(speed) {\n    if (props.visualizingAlgorithm || props.generatingMaze) {\n      return;\n    }\n    let value = [10, 10];\n    if (speed === \"Slow\") value = [50, 30];\n    else if (speed === \"Medium\") value = [25, 20];\n    else if (speed === \"Fast\") value = [10, 10];\n    setSpeedState(speed);\n    props.updateSpeed(value[0], value[1]);\n  }\n\n  return (\n    <nav className=\"navbar navbar-expand navbar-dark bg-dark\">\n      <a className=\"navbar-brand h1 mb-0\" href=\"/\">\n        {brand}\n      </a>\n      <div className=\"collapse navbar-collapse\" id=\"navbarNavDropdown\">\n        <ul className=\"navbar-nav mr-auto\">\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Algorithms\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectAlgorithm(\"Visualize Dijkstra\")}\n                >\n                  Dijkstra's Algorithm\n                </button>\n\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Breadth First Search\")\n                  }\n                >\n                  Breadth First Search\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Depth First Search\")\n                  }\n                >\n                  Depth First Search\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Mazes\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Random Maze\")}\n                >\n                  Random Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Recursive Maze\")}\n                >\n                  Recursive Division Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Vertical Maze\")}\n                >\n                  Vertical Division Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Horizontal Maze\")}\n                >\n                  Horizontal Division Maze\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <a\n                href=\"/#\"\n                className=\"nav-link dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Speed: {speedState}\n              </a>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Slow\")}\n                >\n                  Slow\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Medium\")}\n                >\n                  Medium\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Fast\")}\n                >\n                  Fast\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n        </ul>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-success mr-2\"\n          onClick={() => visualizeAlgorithm()}\n        >\n          {algorithm}\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-success mr-2\"\n          onClick={() => generateMaze()}\n        >\n          {maze}\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-outline-warning mr-2\"\n          onClick={() => clearGrid()}\n        >\n          Clear Gird\n        </button>\n      </div>\n    </nav>\n  );\n};\nexport default NavBar;\n","export function dijkstra(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;      //means we had naver reach at that pt\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);                                   //update distacnes of neighboue nodes\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours\n    .filter((neighbour) => !neighbour.isWall)\n    .filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function breadthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];                // keep track of unvisited nodes \n  let visitedNodesInOrder = [];           //to store path from src to dest\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();    //gives first element of unvisited nodes\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbour);\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode) {          //for printing shortest path\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);        //insert at beginning in array\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function depthFirstSearch(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  let neighbours = [];\n  let { row, col } = node;\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function getNodesInShortestPathOrderDFS(finishNode) {\n  let nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useEffect } from \"react\";\nimport \"./pathfindingVisualizer.css\";\nimport Node from \"./Node/node\";\nimport NavBar from \"./navbar\";\n\n//Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../pathfindingAlgorithms/dijkstra\";\n\nimport {\n  breadthFirstSearch,\n  getNodesInShortestPathOrderBFS,\n} from \"../pathfindingAlgorithms/breadthFirstSearch\";\nimport {\n  depthFirstSearch,\n  getNodesInShortestPathOrderDFS,\n} from \"../pathfindingAlgorithms/depthFirstSearch\";\n\n//Maze Algorithms\nimport { randomMaze } from \"../mazeAlgorithms/randomMaze\";\nimport { recursiveDivisionMaze } from \"../mazeAlgorithms/recursiveDivision\";\nimport { verticalMaze } from \"../mazeAlgorithms/verticalMaze\";\nimport { horizontalMaze } from \"../mazeAlgorithms/horizontalMaze\";\n\n//get number of rows and columns based on windows width\n// finds row and column of grid according to screen dimensions\nconst [initialNumRows, initialNumColumns] = getInitialNum(\n  window.innerWidth,\n  window.innerHeight\n);\n\n//find random source and destination\nlet [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol] =\n  getStartFinishNode(initialNumRows, initialNumColumns);\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [visualizingAlgorithm, setVisualizingAlgorithm] = useState(false);\n  const [generatingMaze, setGeneratingMaze] = useState(false);\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n  const [numRows, setNumRows] = useState(initialNumRows);\n  const [numColumns, setNumColumns] = useState(initialNumColumns);\n  const [speed, setSpeed] = useState(10);\n  const [mazeSpeed, setMazeSpeed] = useState(10);\n\n  //useEffect\n  useEffect(() => {\n    window.addEventListener(\"resize\", updateDimensions);\n    setGrid(getInitialGrid(numRows, numColumns));\n    return () => {\n      window.removeEventListener(\"resize\", updateDimensions);\n    };\n  }, [numRows, numColumns, width]);\n\n  const updateDimensions = () => {\n    setWidth(window.innerWidth);\n    setHeight(window.innerHeight);\n  };\n\n  const updateSpeed = (path, maze) => {\n    setSpeed(path);\n    setMazeSpeed(maze);\n  };\n\n  //when click mouse button wall created\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWalls(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n    //this.setState({ grid: newGrid, mouseIsPressed: true });\n  };\n\n  //when mouse button is pressed and we moving our cursor then wall is created\n  const handleMouseEnter = (row, col) => {\n    if (mouseIsPressed) {\n      const newGrid = getNewGridWithWalls(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n      //this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  };\n\n  //when release mouse button\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n    //this.setState({ mouseIsPressed: false });\n  };\n\n  const clearGrid = () => {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === finishNodeRow && col === finishNodeCol)\n          )\n        ) {\n          //each cell is div so we add the default class inital class-node\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(numRows, numColumns);\n    //making new grid and and assigning it to main grid\n    setGrid(newGrid);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n  };\n\n  const clearPath = () => {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        // only those cell which are traversed becomes default cell again without distubing the walls\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(grid);\n    setGrid(newGrid);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n  };\n\n  //print shortest path\n  const animateShortestPath = (\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    //if only one node is present i.e start and finish is same\n    if (nodesInShortestPathOrder.length === 1) setVisualizingAlgorithm(false);\n    //except the start node\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      //if we reach finish node and we\n      if (i === nodesInShortestPathOrder.length - 1) {\n        //after printing path we render the nodes if we make walls it is ok\n        //but if we rmove walls the it will restore its properties of animation\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n          setVisualizingAlgorithm(false);\n        }, i * (3 * speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * speed));\n    }\n  };\n\n  //all visited nodes and nodes in shortest path\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    setGrid(newGrid);\n    //this.setState({ grid: newGrid });\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      //if we reach the finish node then start animate shortest path route and stop the animate algo fun\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        // just add class node-visited into div to for animation\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  function visualizeDijkstra() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    //this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDijkstra(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    // this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeDFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    // this.setState({ visualizingAlgorithm: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  //animation for walls\n  const animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          clearGrid();\n          let newGrid = getNewGridWithMaze(grid, walls);\n          setGrid(newGrid);\n          setGeneratingMaze(false);\n          //this.setState({ grid: newGrid, generatingMaze: false });\n        }, i * mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * mazeSpeed);\n    }\n  };\n\n  function generateRandomMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    //this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = randomMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateRecursiveDivisionMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    // this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateVerticalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    //this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateHorizontalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    // this.setState({ generatingMaze: true });\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const finishNode = grid[finishNodeRow][finishNodeCol];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  return (\n    <React.Fragment>\n      <NavBar\n        visualizingAlgorithm={visualizingAlgorithm}\n        generatingMaze={generatingMaze}\n        visualizeDijkstra={visualizeDijkstra}\n        visualizeBFS={visualizeBFS}\n        visualizeDFS={visualizeDFS}\n        generateRandomMaze={generateRandomMaze}\n        generateRecursiveDivisionMaze={generateRecursiveDivisionMaze}\n        generateVerticalMaze={generateVerticalMaze}\n        generateHorizontalMaze={generateHorizontalMaze}\n        clearGrid={clearGrid}\n        clearPath={clearPath}\n        updateSpeed={updateSpeed}\n      />\n\n      <div class=\"d-flex flex-row flex-wrap m-2 justify-content-around\">\n        <div class=\"d-flex p-2\">\n          <div class=\"key wall\"></div>\n          <div> Wall</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key start\"></div>\n          <div>Start</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key end\"></div>\n          <div>Target</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key visited\"></div>\n          <div>Visited</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key success\"></div>\n          <div>Shortest-Path</div>\n        </div>\n        <div class=\"d-flex p-2\">\n          <div class=\"key\"></div>\n          <div>Unvisited</div>\n        </div>\n      </div>\n\n      <div\n        className={\n          visualizingAlgorithm || generatingMaze ? \"grid-visualizing\" : \"grid\"\n        }\n      >\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const {\n                  row,\n                  col,\n                  isStart,\n                  isFinish,\n                  isVisited,\n                  isShortest,\n                  isWall,\n                } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isVisited={isVisited}\n                    isShortest={isShortest}\n                    isWall={isWall}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    width={width}\n                    height={height}\n                    numRows={numRows}\n                    numColumns={numColumns}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </React.Fragment>\n  );\n};\n\n// finding rows and columns accoding to width and height\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numColumns];\n}\n\n//function to find random source and destnation nodes\nfunction getStartFinishNode(numRows, numColumns) {\n  //starting node is always in top-left part\n  let startNodeRow = Math.floor(Math.random() * (numRows / 2)) + 1; //added 1 to prevent out of bounds\n  let startNodeCol = Math.floor(Math.random() * (numColumns / 2)) + 1;\n\n  //finishing node is always in bottom-right part\n  let finishNodeRow =\n    Math.floor(numRows / 2) + Math.floor(Math.random() * (numRows / 2)) - 1;\n  let finishNodeCol =\n    Math.floor(numColumns / 2) +\n    Math.floor(Math.random() * (numColumns / 2)) -\n    1;\n\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\n//creating grid\nconst getInitialGrid = (numRows, numColumns) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numColumns; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isFinish: row === finishNodeRow && col === finishNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWalls = (grid, row, col) => {\n  let newGrid = grid.slice(); //copy the old grid\n  let node = grid[row][col]; //updating node's wall\n  let newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getGridWithoutPath = (grid) => {\n  let newGrid = grid.slice(); //copy the old grid\n  for (let row of grid) {\n    // removing paths from each cell of grid\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        totalDistance: Infinity,\n        isVisited: false,\n        isShortest: false,\n        previousNode: null,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\n\nconst updateNodesForRender = (\n  grid,\n  nodesInShortestPathOrder,\n  visitedNodesInOrder\n) => {\n  let newGrid = grid.slice();\n  //after printing path we render the nodes if we make walls it is ok\n  //but if we rmove walls the it will restore its properties of animation\n  for (let node of visitedNodesInOrder) {\n    if (\n      (node.row === startNodeRow && node.col === startNodeCol) ||\n      (node.row === finishNodeRow && node.col === finishNodeCol)\n    )\n      continue;\n    let newNode = {\n      ...node,\n      isVisited: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n  for (let node of nodesInShortestPathOrder) {\n    if (node.row === finishNodeRow && node.col === finishNodeCol) {\n      return newGrid;\n    }\n    let newNode = {\n      ...node,\n      isVisited: false,\n      isShortest: true,\n    };\n    newGrid[node.row][node.col] = newNode;\n  }\n};\n\nexport default PathfindingVisualizer;\n","export function randomMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === finishNode.row && col === finishNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap/js/dist/dropdown\";\nimport PathfindingVisualizer from \"./pathfindingVisualizer/pathfindingVisualizer\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}